<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport"/>
    <meta name="theme-color" content="#6366f1"/>
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
    <meta name="apple-mobile-web-app-title" content="Shape Sort"/>
    <meta name="description" content="A fast-paced cognitive sorting game. Match shapes by color or form in 60 seconds!"/>
    <meta name="mobile-web-app-capable" content="yes"/>
    <meta name="application-name" content="Shape Sort"/>
    
    <title>Shape Sort - Cognitive Sorting Game</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIlNoYXBlIFNvcnQgLSBDb2duaXRpdmUgU29ydGluZyBHYW1lIiwKICAic2hvcnRfbmFtZSI6ICJTaGFwZSBTb3J0IiwKICAiZGVzY3JpcHRpb24iOiAiQSBmYXN0LXBhY2VkIGNvZ25pdGl2ZSBzb3J0aW5nIGdhbWUgdGhhdCB0ZXN0cyB5b3VyIHJlZmxleGVzIGFuZCBwYXR0ZXJuIHJlY29nbml0aW9uLiBNYXRjaCBzaGFwZXMgYnkgY29sb3Igb3IgZm9ybSBpbiA2MCBzZWNvbmRzISIsCiAgInN0YXJ0X3VybCI6ICIuLyIsCiAgImRpc3BsYXkiOiAiZnVsbHNjcmVlbiIsCiAgIm9yaWVudGF0aW9uIjogInBvcnRyYWl0IiwKICAiYmFja2dyb3VuZF9jb2xvciI6ICIjMGYxNzJhIiwKICAidGhlbWVfY29sb3IiOiAiIzYzNjZmMSIsCiAgImNhdGVnb3JpZXMiOiBbImdhbWVzIiwgImVudGVydGFpbm1lbnQiLCAicHV6emxlIl0sCiAgImljb25zIjogWwogICAgewogICAgICAic3JjIjogImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB2aWV3Qm94PScwIDAgNTEyIDUxMiclM0UlM0NyZWN0IHdpZHRoPSc1MTInIGhlaWdodD0nNTEyJyByeD0nMTI4JyBmaWxsPSclMjM2MzY2ZjEnLyUzRSUzQ2NpcmNsZSBjeD0nMjU2JyBjeT0nMjU2JyByPScxNjAnIGZpbGw9J3doaXRlJy8lM0UlM0Nwb2x5Z29uIHBvaW50cz0nMjU2LDE0MCAxODAsMzAwIDMzMiwzMDAnIGZpbGw9JyUyM2VhYjMwOCcvJTNFJTNDL3N2ZyUzRSIsCiAgICAgICJzaXplcyI6ICIxOTJ4MTkyIiwKICAgICAgInR5cGUiOiAiaW1hZ2Uvc3ZnK3htbCIsCiAgICAgICJwdXJwb3NlIjogImFueSBtYXNrYWJsZSIKICAgIH0sCiAgICB7CiAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA1MTIgNTEyJyUzRSUzQ3JlY3Qgd2lkdGg9JzUxMicgaGVpZ2h0PSc1MTInIHJ4PScxMjgnIGZpbGw9JyUyMzYzNjZmMScvJTNFJTNDY2lyY2xlIGN4PScyNTYnIGN5PScyNTYnIHI9JzE2MCcgZmlsbD0nd2hpdGUnLyUzRSUzQ3BvbHlnb24gcG9pbnRzPScyNTYsMTQwIDE4MCwzMDAgMzMyLDMwMCcgZmlsbD0nJTIzZWFiMzA4Jy8lM0UlM0Mvc3ZnJTNFIiwKICAgICAgInNpemVzIjogIjUxMng1MTIiLAogICAgICAidHlwZSI6ICJpbWFnZS9zdmcreG1sIiwKICAgICAgInB1cnBvc2UiOiAiYW55IG1hc2thYmxlIgogICAgfQogIF0sCiAgInNjcmVlbnNob3RzIjogW10sCiAgInNob3J0Y3V0cyI6IFsKICAgIHsKICAgICAgIm5hbWUiOiAiUGxheSBOb3ciLAogICAgICAidXJsIjogIi4vP2FjdGlvbj1wbGF5IiwKICAgICAgImRlc2NyaXB0aW9uIjogIlN0YXJ0IGEgbmV3IGdhbWUgaW1tZWRpYXRlbHkiCiAgICB9CiAgXQp9">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com" rel="preconnect"/>
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet"/>
    
    <!-- Tailwind -->
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography"></script>
    <script>
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        primary: "#6366f1",
                        "background-light": "#f8fafc",
                        "background-dark": "#0f172a",
                        "game-red": "#ef4444",
                        "game-blue": "#3b82f6",
                        "game-green": "#22c55e",
                        "game-yellow": "#eab308",
                    },
                    fontFamily: {
                        display: ["Outfit", "sans-serif"],
                    },
                },
            },
        };
    </script>
    
    <style>
        /* Animations */
        @keyframes bounceIn {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-8px); }
            40% { transform: translateX(8px); }
            60% { transform: translateX(-8px); }
            80% { transform: translateX(8px); }
        }
        @keyframes pulse-ring {
            0% { transform: scale(1); opacity: 0.8; }
            100% { transform: scale(1.5); opacity: 0; }
        }
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        @keyframes slideUp {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes slideDown {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes zoomIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        @keyframes particleExplosion {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }
        @keyframes modeSwitchPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        @keyframes countdown {
            0% { transform: scale(1.5); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0; }
        }
        @keyframes ringProgress {
            from { stroke-dashoffset: 283; }
        }
        @keyframes glowPulse {
            0%, 100% { box-shadow: 0 0 20px currentColor; }
            50% { box-shadow: 0 0 40px currentColor, 0 0 60px currentColor; }
        }
        
        .animate-bounce-in { animation: bounceIn 0.5s ease-out; }
        .animate-shake { animation: shake 0.5s ease-in-out; }
        .animate-float { animation: float 3s ease-in-out infinite; }
        .animate-slide-up { animation: slideUp 0.5s ease-out; }
        .animate-slide-down { animation: slideDown 0.5s ease-out; }
        .animate-zoom-in { animation: zoomIn 0.3s ease-out; }
        .animate-mode-switch { animation: modeSwitchPulse 0.5s ease-in-out 3; }
        
        .particle {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            pointer-events: none;
            animation: particleExplosion 0.8s ease-out forwards;
        }
        
        .quadrant-wrong { animation: shake 0.5s ease-out; }
        
        .draggable-shape {
            transition: transform 0.1s ease-out, box-shadow 0.2s ease;
            cursor: grab;
            touch-action: none;
        }
        
        .draggable-shape:active {
            cursor: grabbing;
        }
        
        .draggable-shape.dragging {
            transition: none;
            z-index: 1000;
            transform: scale(1.15);
            box-shadow: 0 20px 40px rgba(0,0,0,0.3);
        }
        
        .draggable-shape.returning {
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        .combo-text {
            position: absolute;
            font-weight: 800;
            font-size: 1.5rem;
            pointer-events: none;
            animation: slideUp 0.6s ease-out forwards;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .time-warning {
            color: #ef4444 !important;
            animation: pulse 0.5s infinite;
        }
        
        .score-pop { animation: bounceIn 0.3s ease-out; }
        
        .mode-switch-overlay {
            backdrop-filter: blur(8px);
        }
        
        body {
            touch-action: none;
            overscroll-behavior: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        * { -webkit-tap-highlight-color: transparent; }
        
        .center-holder {
            position: relative;
        }
        
        .center-holder::after {
            content: '';
            position: absolute;
            inset: -10px;
            border-radius: 50%;
            border: 2px dashed rgba(99, 102, 241, 0.3);
            animation: pulse-ring 2s ease-out infinite;
        }
        
        .progress-ring-bg {
            stroke: rgba(255,255,255,0.1);
        }
        
        .progress-ring-fill {
            transition: stroke-dashoffset 0.1s linear;
            transform: rotate(-90deg);
            transform-origin: center;
        }
    </style>
</head>

<body class="bg-background-light dark:bg-background-dark font-display h-screen flex flex-col overflow-hidden select-none">
    
    <!-- Header -->
    <header class="flex-none h-20 px-4 sm:px-6 flex justify-between items-center bg-white dark:bg-slate-800 shadow-md z-30 relative">
        <!-- Score -->
        <div class="flex flex-col min-w-[80px]">
            <span class="text-xs uppercase tracking-wider text-slate-400 font-bold">Score</span>
            <div class="flex items-center gap-2">
                <span id="scoreDisplay" class="text-2xl font-800 text-slate-800 dark:text-white">0</span>
                <div id="streakBadge" class="hidden px-2 py-0.5 rounded-full bg-gradient-to-r from-orange-400 to-red-500 text-white text-xs font-bold whitespace-nowrap">
                    ðŸ”¥ <span id="streakCount">0</span>x
                </div>
            </div>
        </div>
        
        <!-- Mode Indicator -->
        <div class="absolute left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2">
            <div id="modeBadge" class="mode-badge px-3 py-1.5 rounded-full text-xs font-bold uppercase tracking-wider border-2 transition-all duration-300 bg-gradient-to-r from-game-yellow to-orange-500 text-white border-game-yellow shadow-lg">
                <span id="modeText" class="flex items-center gap-1">
                    <span class="material-icons-round text-sm">palette</span>
                    Color
                </span>
            </div>
        </div>
        
        <!-- Timer with Progress Ring -->
        <div class="flex flex-col items-end min-w-[80px]">
            <span class="text-xs uppercase tracking-wider text-slate-400 font-bold">Time</span>
            <div class="flex items-center gap-2">
                <div class="relative w-8 h-8">
                    <svg class="w-8 h-8 transform -rotate-90" viewBox="0 0 36 36">
                        <circle class="progress-ring-bg" cx="18" cy="18" r="15" fill="none" stroke-width="3"/>
                        <circle id="progressRing" class="progress-ring-fill text-primary" cx="18" cy="18" r="15" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-dasharray="94.2" stroke-dashoffset="0"/>
                    </svg>
                </div>
                <span id="timeDisplay" class="text-2xl font-800 text-primary tabular-nums">01:00</span>
            </div>
        </div>
    </header>

    <!-- Main Game Area -->
    <main id="gameArea" class="flex-1 relative w-full">
        <!-- Quadrants -->
        <div class="absolute inset-0 grid grid-cols-2 grid-rows-2 w-full h-full">
            <!-- Red Quadrant (Top-Left) - Square -->
            <div id="quadrant-red" data-color="red" data-shape="square" class="quadrant relative bg-red-100 dark:bg-red-900/30 border-r-2 border-b-2 border-white/30 dark:border-slate-700/50 flex items-center justify-center group transition-all duration-200">
                <div class="absolute inset-0 bg-game-red opacity-5 dark:opacity-10 group-hover:opacity-15 transition-opacity pointer-events-none"></div>
                <div class="quadrant-flash absolute inset-0 bg-game-red opacity-0 pointer-events-none transition-opacity"></div>
                <div class="flex flex-col items-center gap-2 opacity-30 pointer-events-none">
                    <span class="material-icons-round text-5xl sm:text-6xl text-game-red">crop_square</span>
                    <span class="text-xs font-bold text-game-red uppercase tracking-wider hidden sm:block">Square / Red</span>
                </div>
            </div>
            
            <!-- Green Quadrant (Top-Right) - Circle -->
            <div id="quadrant-green" data-color="green" data-shape="circle" class="quadrant relative bg-green-100 dark:bg-green-900/30 border-b-2 border-white/30 dark:border-slate-700/50 flex items-center justify-center group transition-all duration-200">
                <div class="absolute inset-0 bg-game-green opacity-5 dark:opacity-10 group-hover:opacity-15 transition-opacity pointer-events-none"></div>
                <div class="quadrant-flash absolute inset-0 bg-game-green opacity-0 pointer-events-none transition-opacity"></div>
                <div class="flex flex-col items-center gap-2 opacity-30 pointer-events-none">
                    <span class="material-icons-round text-5xl sm:text-6xl text-game-green">circle</span>
                    <span class="text-xs font-bold text-game-green uppercase tracking-wider hidden sm:block">Circle / Green</span>
                </div>
            </div>
            
            <!-- Blue Quadrant (Bottom-Left) - Triangle -->
            <div id="quadrant-blue" data-color="blue" data-shape="triangle" class="quadrant relative bg-blue-100 dark:bg-blue-900/30 border-r-2 border-white/30 dark:border-slate-700/50 flex items-center justify-center group transition-all duration-200">
                <div class="absolute inset-0 bg-game-blue opacity-5 dark:opacity-10 group-hover:opacity-15 transition-opacity pointer-events-none"></div>
                <div class="quadrant-flash absolute inset-0 bg-game-blue opacity-0 pointer-events-none transition-opacity"></div>
                <div class="flex flex-col items-center gap-2 opacity-30 pointer-events-none">
                    <span class="material-icons-round text-5xl sm:text-6xl text-game-blue">change_history</span>
                    <span class="text-xs font-bold text-game-blue uppercase tracking-wider hidden sm:block">Triangle / Blue</span>
                </div>
            </div>
            
            <!-- Yellow Quadrant (Bottom-Right) - Star -->
            <div id="quadrant-yellow" data-color="yellow" data-shape="star" class="quadrant relative bg-yellow-100 dark:bg-yellow-900/30 flex items-center justify-center group transition-all duration-200">
                <div class="absolute inset-0 bg-game-yellow opacity-5 dark:opacity-10 group-hover:opacity-15 transition-opacity pointer-events-none"></div>
                <div class="quadrant-flash absolute inset-0 bg-game-yellow opacity-0 pointer-events-none transition-opacity"></div>
                <div class="flex flex-col items-center gap-2 opacity-30 pointer-events-none">
                    <span class="material-icons-round text-5xl sm:text-6xl text-game-yellow">star</span>
                    <span class="text-xs font-bold text-game-yellow uppercase tracking-wider hidden sm:block">Star / Yellow</span>
                </div>
            </div>
        </div>
        
        <!-- Center Grid Lines -->
        <div class="absolute inset-0 pointer-events-none z-10">
            <div class="absolute left-1/2 top-0 bottom-0 w-0.5 bg-white/50 dark:bg-slate-600/50 transform -translate-x-1/2"></div>
            <div class="absolute top-1/2 left-0 right-0 h-0.5 bg-white/50 dark:bg-slate-600/50 transform -translate-y-1/2"></div>
        </div>
        
        <!-- Fixed Center Holder -->
        <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-20 pointer-events-none">
            <div id="centerHolder" class="center-holder w-32 h-32 sm:w-36 sm:h-36 rounded-full bg-white/90 dark:bg-slate-800/90 shadow-2xl flex items-center justify-center border-4 border-slate-200 dark:border-slate-600 backdrop-blur-sm">
                <!-- Shape spawns here but is moved out for dragging -->
            </div>
        </div>
        
        <!-- Draggable Shape (separate from holder) -->
        <div id="draggableShape" class="draggable-shape absolute z-30 w-20 h-20 sm:w-24 sm:h-24 rounded-2xl flex items-center justify-center" style="top: 50%; left: 50%; transform: translate(-50%, -50%);">
            <!-- Shape icon inserted here -->
        </div>
        
        <!-- Particles Container -->
        <div id="particlesContainer" class="absolute inset-0 pointer-events-none z-40"></div>
        
        <!-- Combo Text Container -->
        <div id="comboContainer" class="absolute inset-0 pointer-events-none z-35"></div>
    </main>

    <!-- Footer -->
    <footer class="flex-none h-14 bg-white dark:bg-slate-800 border-t border-slate-200 dark:border-slate-700 flex items-center justify-center z-30 px-4">
        <p id="instructionText" class="text-sm text-slate-500 dark:text-slate-400 font-medium flex items-center gap-2 text-center">
            <span class="material-icons-round text-lg text-primary">swipe</span>
            Drag shape to matching <span id="matchType" class="text-primary font-bold">COLOR</span> zone
        </p>
    </footer>

    <!-- Mode Switch Overlay -->
    <div id="modeSwitchOverlay" class="hidden fixed inset-0 bg-black/70 mode-switch-overlay z-50 flex items-center justify-center">
        <div class="text-center animate-zoom-in">
            <div id="modeSwitchIcon" class="w-24 h-24 mx-auto mb-4 rounded-full flex items-center justify-center text-white text-5xl">
                <span class="material-icons-round">category</span>
            </div>
            <h2 class="text-4xl font-800 text-white mb-2">MODE SWITCH!</h2>
            <p id="modeSwitchText" class="text-xl text-white/80">Now match by SHAPE</p>
            <div class="mt-6 flex justify-center gap-2">
                <div class="w-3 h-3 rounded-full bg-white animate-bounce" style="animation-delay: 0s;"></div>
                <div class="w-3 h-3 rounded-full bg-white animate-bounce" style="animation-delay: 0.1s;"></div>
                <div class="w-3 h-3 rounded-full bg-white animate-bounce" style="animation-delay: 0.2s;"></div>
            </div>
        </div>
    </div>

    <!-- Game Over Overlay -->
    <div id="gameOverOverlay" class="hidden fixed inset-0 bg-black/70 backdrop-blur-sm z-50 flex items-center justify-center p-4">
        <div class="bg-white dark:bg-slate-800 rounded-3xl p-6 sm:p-8 max-w-sm w-full shadow-2xl animate-bounce-in">
            <div class="w-20 h-20 mx-auto mb-4 rounded-full bg-gradient-to-br from-primary to-purple-600 flex items-center justify-center shadow-lg">
                <span class="material-icons-round text-4xl text-white">emoji_events</span>
            </div>
            <h2 class="text-3xl font-800 text-slate-800 dark:text-white mb-2 text-center">Time's Up!</h2>
            <p class="text-slate-500 dark:text-slate-400 mb-6 text-center">Great effort! Here's how you did:</p>
            
            <div class="bg-gradient-to-br from-primary/10 to-purple-500/10 dark:from-primary/20 dark:to-purple-500/20 rounded-2xl p-6 mb-6 text-center border border-primary/20">
                <div class="text-5xl font-800 bg-gradient-to-r from-primary to-purple-600 bg-clip-text text-transparent mb-1" id="finalScore">0</div>
                <div class="text-sm text-slate-500 dark:text-slate-400 font-medium">Total Points</div>
            </div>
            
            <div class="grid grid-cols-3 gap-3 mb-6">
                <div class="bg-green-50 dark:bg-green-900/30 rounded-xl p-3 text-center">
                    <div class="text-2xl font-800 text-game-green" id="correctCount">0</div>
                    <div class="text-xs text-slate-500 dark:text-slate-400">Correct</div>
                </div>
                <div class="bg-red-50 dark:bg-red-900/30 rounded-xl p-3 text-center">
                    <div class="text-2xl font-800 text-game-red" id="wrongCount">0</div>
                    <div class="text-xs text-slate-500 dark:text-slate-400">Wrong</div>
                </div>
                <div class="bg-yellow-50 dark:bg-yellow-900/30 rounded-xl p-3 text-center">
                    <div class="text-2xl font-800 text-game-yellow" id="maxStreak">0</div>
                    <div class="text-xs text-slate-500 dark:text-slate-400">Best Streak</div>
                </div>
            </div>
            
            <button id="playAgainBtn" class="w-full py-4 bg-gradient-to-r from-primary to-purple-600 text-white font-bold rounded-xl hover:opacity-90 active:scale-[0.98] transition-all shadow-lg text-lg">
                <span class="flex items-center justify-center gap-2">
                    <span class="material-icons-round">replay</span>
                    Play Again
                </span>
            </button>
        </div>
    </div>

    <!-- Start Screen Overlay -->
    <div id="startOverlay" class="fixed inset-0 bg-gradient-to-br from-slate-900 via-primary/90 to-purple-900 z-50 flex items-center justify-center p-4">
        <div class="bg-white dark:bg-slate-800 rounded-3xl p-6 sm:p-8 max-w-sm w-full shadow-2xl animate-slide-up">
            <div class="w-24 h-24 mx-auto mb-6 rounded-full bg-gradient-to-br from-game-yellow to-orange-500 flex items-center justify-center shadow-xl animate-float">
                <span class="material-icons-round text-5xl text-white">psychology</span>
            </div>
            <h1 class="text-3xl font-800 text-slate-800 dark:text-white mb-2 text-center">Shape Sort</h1>
            <p class="text-slate-500 dark:text-slate-400 mb-6 text-center">Test your reflexes in 60 seconds!</p>
            
            <div class="bg-slate-50 dark:bg-slate-700/50 rounded-xl p-4 mb-6">
                <h3 class="font-bold text-slate-700 dark:text-slate-300 mb-3 flex items-center gap-2">
                    <span class="material-icons-round text-primary">help_outline</span>
                    How to Play
                </h3>
                <ul class="text-sm text-slate-600 dark:text-slate-400 space-y-3">
                    <li class="flex items-start gap-3">
                        <span class="w-6 h-6 rounded-full bg-game-yellow/20 flex items-center justify-center flex-shrink-0 mt-0.5">
                            <span class="text-game-yellow text-xs font-bold">1</span>
                        </span>
                        <span><strong class="text-game-yellow">First 30s:</strong> Match shapes by COLOR</span>
                    </li>
                    <li class="flex items-start gap-3">
                        <span class="w-6 h-6 rounded-full bg-purple-500/20 flex items-center justify-center flex-shrink-0 mt-0.5">
                            <span class="text-purple-500 text-xs font-bold">2</span>
                        </span>
                        <span><strong class="text-purple-500">Last 30s:</strong> Match shapes by SHAPE</span>
                    </li>
                    <li class="flex items-start gap-3">
                        <span class="w-6 h-6 rounded-full bg-game-green/20 flex items-center justify-center flex-shrink-0 mt-0.5">
                            <span class="text-game-green text-xs font-bold">ðŸ”¥</span>
                        </span>
                        <span>Build <strong class="text-game-green">streaks</strong> for bonus points!</span>
                    </li>
                </ul>
            </div>
            
            <button id="startGameBtn" class="w-full py-4 bg-gradient-to-r from-game-green to-emerald-600 text-white font-bold rounded-xl hover:opacity-90 active:scale-[0.98] transition-all shadow-lg text-lg">
                <span class="flex items-center justify-center gap-2">
                    <span class="material-icons-round">play_arrow</span>
                    Start Game
                </span>
            </button>
            
            <p class="text-center text-xs text-slate-400 mt-4">
                Best played on mobile ðŸ“±
            </p>
        </div>
    </div>

    <script>
        // =====================
        // GAME STATE
        // =====================
        const GameState = {
            score: 0,
            timeLeft: 60,
            isPlaying: false,
            currentMode: 'color',
            currentShape: null,
            streak: 0,
            maxStreak: 0,
            correctCount: 0,
            wrongCount: 0,
            isDragging: false,
            dragOffset: { x: 0, y: 0 },
            timerInterval: null,
            modeSwitched: false,
        };

        // =====================
        // CONSTANTS
        // =====================
        const SHAPES = ['square', 'circle', 'triangle', 'star'];
        const COLORS = ['red', 'green', 'blue', 'yellow'];
        
        const COLOR_MAP = {
            red: '#ef4444',
            green: '#22c55e',
            blue: '#3b82f6',
            yellow: '#eab308'
        };

        const SHAPE_ICONS = {
            square: 'crop_square',
            circle: 'circle',
            triangle: 'change_history',
            star: 'star'
        };

        const BASE_POINTS = 100;
        const STREAK_BONUS = 25;
        const MAX_STREAK_MULTIPLIER = 5;
        const MODE_SWITCH_TIME = 30;
        const MODE_SWITCH_DURATION = 2000;

        // =====================
        // DOM ELEMENTS
        // =====================
        const $ = (id) => document.getElementById(id);
        
        const elements = {
            scoreDisplay: $('scoreDisplay'),
            timeDisplay: $('timeDisplay'),
            progressRing: $('progressRing'),
            modeBadge: $('modeBadge'),
            modeText: $('modeText'),
            matchType: $('matchType'),
            centerHolder: $('centerHolder'),
            draggableShape: $('draggableShape'),
            gameArea: $('gameArea'),
            particlesContainer: $('particlesContainer'),
            comboContainer: $('comboContainer'),
            streakBadge: $('streakBadge'),
            streakCount: $('streakCount'),
            gameOverOverlay: $('gameOverOverlay'),
            startOverlay: $('startOverlay'),
            modeSwitchOverlay: $('modeSwitchOverlay'),
            modeSwitchIcon: $('modeSwitchIcon'),
            modeSwitchText: $('modeSwitchText'),
            finalScore: $('finalScore'),
            correctCount: $('correctCount'),
            wrongCount: $('wrongCount'),
            maxStreak: $('maxStreak'),
            playAgainBtn: $('playAgainBtn'),
            startGameBtn: $('startGameBtn'),
            quadrants: document.querySelectorAll('.quadrant'),
        };

        // =====================
        // UTILITY FUNCTIONS
        // =====================
        function getGameAreaRect() {
            return elements.gameArea.getBoundingClientRect();
        }

        function getCenterPosition() {
            const rect = getGameAreaRect();
            return { x: rect.width / 2, y: rect.height / 2 };
        }

        function randomFrom(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // =====================
        // SHAPE MANAGEMENT
        // =====================
        function generateRandomShape() {
            return {
                color: randomFrom(COLORS),
                shape: randomFrom(SHAPES)
            };
        }

        function renderShape(shapeData) {
            GameState.currentShape = shapeData;
            const { color, shape } = shapeData;
            
            elements.draggableShape.innerHTML = `
                <span class="material-icons-round text-6xl sm:text-7xl drop-shadow-lg" style="color: ${COLOR_MAP[color]}">
                    ${SHAPE_ICONS[shape]}
                </span>
            `;
            
            elements.draggableShape.style.backgroundColor = `${COLOR_MAP[color]}20`;
            elements.draggableShape.style.border = `3px solid ${COLOR_MAP[color]}40`;
            elements.draggableShape.classList.add('animate-bounce-in');
            
            setTimeout(() => {
                elements.draggableShape.classList.remove('animate-bounce-in');
            }, 500);
        }

        function spawnNewShape() {
            renderShape(generateRandomShape());
            returnToCenter();
        }

        function returnToCenter() {
            const center = getCenterPosition();
            const rect = getGameAreaRect();
            
            elements.draggableShape.classList.add('returning');
            elements.draggableShape.classList.remove('dragging');
            
            elements.draggableShape.style.left = '50%';
            elements.draggableShape.style.top = '50%';
            elements.draggableShape.style.transform = 'translate(-50%, -50%)';
            
            setTimeout(() => {
                elements.draggableShape.classList.remove('returning');
            }, 400);
        }

        // =====================
        // SCORING
        // =====================
        function updateScore(points) {
            GameState.score += points;
            elements.scoreDisplay.textContent = GameState.score.toLocaleString();
            elements.scoreDisplay.classList.add('score-pop');
            setTimeout(() => elements.scoreDisplay.classList.remove('score-pop'), 300);
        }

        function updateStreak(correct) {
            if (correct) {
                GameState.streak++;
                GameState.maxStreak = Math.max(GameState.maxStreak, GameState.streak);
                
                if (GameState.streak >= 3) {
                    elements.streakBadge.classList.remove('hidden');
                    elements.streakCount.textContent = GameState.streak;
                    elements.streakBadge.classList.add('animate-bounce-in');
                }
            } else {
                GameState.streak = 0;
                elements.streakBadge.classList.add('hidden');
            }
        }

        // =====================
        // VISUAL EFFECTS
        // =====================
        function createParticles(x, y, color) {
            const count = 15;
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.backgroundColor = color;
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                
                const angle = (i / count) * Math.PI * 2;
                const distance = 60 + Math.random() * 60;
                particle.style.setProperty('--tx', Math.cos(angle) * distance + 'px');
                particle.style.setProperty('--ty', Math.sin(angle) * distance + 'px');
                
                elements.particlesContainer.appendChild(particle);
                setTimeout(() => particle.remove(), 800);
            }
        }

        function showComboText(x, y, text, color) {
            const combo = document.createElement('div');
            combo.className = 'combo-text';
            combo.textContent = text;
            combo.style.left = x + 'px';
            combo.style.top = (y - 40) + 'px';
            combo.style.color = color;
            combo.style.transform = 'translateX(-50%)';
            
            elements.comboContainer.appendChild(combo);
            setTimeout(() => combo.remove(), 600);
        }

        function flashQuadrant(quadrant, color, isCorrect = true) {
            const flash = quadrant.querySelector('.quadrant-flash');
            flash.style.backgroundColor = isCorrect ? color : '#ef4444';
            flash.style.opacity = '0.4';
            setTimeout(() => { flash.style.opacity = '0'; }, 250);
        }

        // =====================
        // ANSWER HANDLING
        // =====================
        function handleCorrect(quadrant) {
            GameState.correctCount++;
            updateStreak(true);
            
            const streakBonus = Math.min(GameState.streak - 1, MAX_STREAK_MULTIPLIER) * STREAK_BONUS;
            const totalPoints = BASE_POINTS + streakBonus;
            updateScore(totalPoints);
            
            // Visual feedback
            const rect = quadrant.getBoundingClientRect();
            const gameRect = getGameAreaRect();
            const centerX = rect.left - gameRect.left + rect.width / 2;
            const centerY = rect.top - gameRect.top + rect.height / 2;
            
            const color = COLOR_MAP[GameState.currentShape.color];
            createParticles(centerX, centerY, color);
            
            const comboText = GameState.streak >= 3 
                ? `ðŸ”¥ ${GameState.streak}x COMBO!` 
                : `+${totalPoints}`;
            showComboText(centerX, centerY, comboText, color);
            
            flashQuadrant(quadrant, color, true);
            
            // Haptic feedback
            if (navigator.vibrate) navigator.vibrate(50);
            
            setTimeout(spawnNewShape, 150);
        }

        function handleWrong(quadrant) {
            GameState.wrongCount++;
            updateStreak(false);
            
            quadrant.classList.add('quadrant-wrong');
            elements.draggableShape.classList.add('animate-shake');
            
            flashQuadrant(quadrant, '#ef4444', false);
            
            if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
            
            setTimeout(() => {
                quadrant.classList.remove('quadrant-wrong');
                elements.draggableShape.classList.remove('animate-shake');
            }, 500);
            
            returnToCenter();
        }

        // =====================
        // QUADRANT DETECTION
        // =====================
        function getQuadrantAtPosition(clientX, clientY) {
            const rect = getGameAreaRect();
            const relX = clientX - rect.left;
            const relY = clientY - rect.top;
            
            // Center dead zone
            const centerThreshold = 70;
            const distFromCenter = Math.hypot(relX - rect.width / 2, relY - rect.height / 2);
            if (distFromCenter < centerThreshold) return null;
            
            const isLeft = relX < rect.width / 2;
            const isTop = relY < rect.height / 2;
            
            if (isLeft && isTop) return $('quadrant-red');
            if (!isLeft && isTop) return $('quadrant-green');
            if (isLeft && !isTop) return $('quadrant-blue');
            return $('quadrant-yellow');
        }

        function checkDrop(quadrant) {
            if (!quadrant || !GameState.currentShape) return;
            
            const targetColor = quadrant.dataset.color;
            const targetShape = quadrant.dataset.shape;
            
            const isCorrect = GameState.currentMode === 'color'
                ? GameState.currentShape.color === targetColor
                : GameState.currentShape.shape === targetShape;
            
            isCorrect ? handleCorrect(quadrant) : handleWrong(quadrant);
        }

        // =====================
        // DRAG HANDLING
        // =====================
        function getEventCoords(e) {
            const touch = e.touches?.[0] || e.changedTouches?.[0];
            return touch 
                ? { x: touch.clientX, y: touch.clientY }
                : { x: e.clientX, y: e.clientY };
        }

        function handleDragStart(e) {
            if (!GameState.isPlaying) return;
            e.preventDefault();
            
            GameState.isDragging = true;
            elements.draggableShape.classList.add('dragging');
            elements.draggableShape.classList.remove('returning');
            
            const coords = getEventCoords(e);
            const rect = elements.draggableShape.getBoundingClientRect();
            
            GameState.dragOffset = {
                x: coords.x - (rect.left + rect.width / 2),
                y: coords.y - (rect.top + rect.height / 2)
            };
        }

        function handleDragMove(e) {
            if (!GameState.isDragging) return;
            e.preventDefault();
            
            const coords = getEventCoords(e);
            const gameRect = getGameAreaRect();
            
            const x = coords.x - gameRect.left - GameState.dragOffset.x;
            const y = coords.y - gameRect.top - GameState.dragOffset.y;
            
            elements.draggableShape.style.left = x + 'px';
            elements.draggableShape.style.top = y + 'px';
            elements.draggableShape.style.transform = 'translate(-50%, -50%) scale(1.15)';
            
            // Highlight potential drop zone
            const quadrant = getQuadrantAtPosition(coords.x, coords.y);
            elements.quadrants.forEach(q => {
                q.style.transform = q === quadrant ? 'scale(1.03)' : 'scale(1)';
                q.style.opacity = q === quadrant ? '1' : '0.85';
            });
        }

        function handleDragEnd(e) {
            if (!GameState.isDragging) return;
            
            GameState.isDragging = false;
            elements.draggableShape.classList.remove('dragging');
            
            elements.quadrants.forEach(q => {
                q.style.transform = 'scale(1)';
                q.style.opacity = '1';
            });
            
            const coords = getEventCoords(e);
            const quadrant = getQuadrantAtPosition(coords.x, coords.y);
            
            quadrant ? checkDrop(quadrant) : returnToCenter();
        }

        // =====================
        // MODE MANAGEMENT
        // =====================
        function switchMode() {
            GameState.currentMode = 'shape';
            GameState.modeSwitched = true;
            
            // Show overlay
            elements.modeSwitchOverlay.classList.remove('hidden');
            elements.modeSwitchIcon.style.background = 'linear-gradient(135deg, #a855f7, #6366f1)';
            elements.modeSwitchText.textContent = 'Now match by SHAPE!';
            
            // Pause dragging during switch
            GameState.isPlaying = false;
            
            setTimeout(() => {
                elements.modeSwitchOverlay.classList.add('hidden');
                GameState.isPlaying = true;
                
                // Update UI
                updateModeUI();
            }, MODE_SWITCH_DURATION);
        }

        function updateModeUI() {
            if (GameState.currentMode === 'color') {
                elements.modeBadge.className = 'mode-badge px-3 py-1.5 rounded-full text-xs font-bold uppercase tracking-wider border-2 transition-all duration-300 bg-gradient-to-r from-game-yellow to-orange-500 text-white border-game-yellow shadow-lg';
                elements.modeText.innerHTML = '<span class="material-icons-round text-sm">palette</span> Color';
                elements.matchType.textContent = 'COLOR';
                elements.matchType.className = 'text-game-yellow font-bold';
            } else {
                elements.modeBadge.className = 'mode-badge px-3 py-1.5 rounded-full text-xs font-bold uppercase tracking-wider border-2 transition-all duration-300 bg-gradient-to-r from-purple-500 to-primary text-white border-purple-500 shadow-lg animate-mode-switch';
                elements.modeText.innerHTML = '<span class="material-icons-round text-sm">category</span> Shape';
                elements.matchType.textContent = 'SHAPE';
                elements.matchType.className = 'text-purple-500 font-bold';
            }
        }

        // =====================
        // TIMER
        // =====================
        function updateTimer() {
            GameState.timeLeft--;
            
            // Format time
            const minutes = Math.floor(GameState.timeLeft / 60);
            const seconds = GameState.timeLeft % 60;
            elements.timeDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            
            // Update progress ring (circumference = 2 * PI * 15 â‰ˆ 94.2)
            const progress = (60 - GameState.timeLeft) / 60;
            elements.progressRing.style.strokeDashoffset = 94.2 * progress;
            
            // Mode switch at 30 seconds
            if (GameState.timeLeft === MODE_SWITCH_TIME && !GameState.modeSwitched) {
                switchMode();
            }
            
            // Warning at 10 seconds
            if (GameState.timeLeft <= 10) {
                elements.timeDisplay.classList.add('time-warning');
                elements.progressRing.classList.add('text-game-red');
            }
            
            // Game over
            if (GameState.timeLeft <= 0) {
                endGame();
            }
        }

        // =====================
        // GAME LIFECYCLE
        // =====================
        function startGame() {
            // Reset state
            Object.assign(GameState, {
                score: 0,
                timeLeft: 60,
                streak: 0,
                maxStreak: 0,
                correctCount: 0,
                wrongCount: 0,
                isPlaying: true,
                currentMode: 'color',
                modeSwitched: false,
            });
            
            // Reset UI
            elements.scoreDisplay.textContent = '0';
            elements.timeDisplay.textContent = '01:00';
            elements.timeDisplay.classList.remove('time-warning');
            elements.progressRing.style.strokeDashoffset = '0';
            elements.progressRing.classList.remove('text-game-red');
            elements.streakBadge.classList.add('hidden');
            elements.startOverlay.classList.add('hidden');
            elements.gameOverOverlay.classList.add('hidden');
            
            updateModeUI();
            spawnNewShape();
            
            // Start timer
            GameState.timerInterval = setInterval(updateTimer, 1000);
        }

        function endGame() {
            GameState.isPlaying = false;
            clearInterval(GameState.timerInterval);
            
            // Update final stats
            elements.finalScore.textContent = GameState.score.toLocaleString();
            elements.correctCount.textContent = GameState.correctCount;
            elements.wrongCount.textContent = GameState.wrongCount;
            elements.maxStreak.textContent = GameState.maxStreak;
            
            // Haptic feedback
            if (navigator.vibrate) navigator.vibrate([100, 50, 100, 50, 100]);
            
            elements.gameOverOverlay.classList.remove('hidden');
        }

        // =====================
        // EVENT LISTENERS
        // =====================
        // Drag events
        elements.draggableShape.addEventListener('mousedown', handleDragStart);
        elements.draggableShape.addEventListener('touchstart', handleDragStart, { passive: false });
        
        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('touchmove', handleDragMove, { passive: false });
        
        document.addEventListener('mouseup', handleDragEnd);
        document.addEventListener('touchend', handleDragEnd);

        // Buttons
        elements.startGameBtn.addEventListener('click', startGame);
        elements.playAgainBtn.addEventListener('click', startGame);

        // Prevent context menu on long press
        document.addEventListener('contextmenu', e => e.preventDefault());

        // =====================
        // PWA SERVICE WORKER
        // =====================
        if ('serviceWorker' in navigator) {
            // Create inline service worker for offline capability
            const swCode = `
                const CACHE_NAME = 'shape-sort-v1';
                const ASSETS = [
                    './',
                    './index.html',
                    'https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap',
                    'https://fonts.googleapis.com/icon?family=Material+Icons+Round'
                ];
                
                self.addEventListener('install', e => {
                    e.waitUntil(
                        caches.open(CACHE_NAME)
                            .then(cache => cache.addAll(ASSETS))
                            .then(() => self.skipWaiting())
                    );
                });
                
                self.addEventListener('activate', e => {
                    e.waitUntil(
                        caches.keys().then(keys => 
                            Promise.all(keys.filter(k => k !== CACHE_NAME).map(k => caches.delete(k)))
                        ).then(() => self.clients.claim())
                    );
                });
                
                self.addEventListener('fetch', e => {
                    e.respondWith(
                        caches.match(e.request)
                            .then(res => res || fetch(e.request))
                            .catch(() => caches.match('./index.html'))
                    );
                });
            `;
            
            const swBlob = new Blob([swCode], { type: 'application/javascript' });
            const swUrl = URL.createObjectURL(swBlob);
            
            navigator.serviceWorker.register(swUrl)
                .then(reg => console.log('SW registered:', reg.scope))
                .catch(err => console.log('SW registration failed:', err));
        }

        // =====================
        // INITIALIZATION
        // =====================
        console.log('ðŸŽ® Shape Sort Game Loaded');
        console.log('ðŸ“± PWA Ready');
    </script>
</body>
</html>
